# 스마트 컨베이어 안전 시스템: Gemini 협업 기록

## 🎯 프로젝트 목표

작업 현장에서 발생할 수 있는 ‘끼임 사고’를 방지하기 위한 스마트 안전 시스템 구축. 특히 **비정형 작업 중**에는 전원을 물리적으로 차단하여 **사람이 있는 상황에서 컨베이어벨트를 작동시키지 않도록** 하는 것이 핵심 목표.

---

## ✅ 핵심 요구사항 및 작업 모드 정의

이 시스템은 두 가지 핵심 작업 모드를 정의하고, 각 모드에 따라 다른 안전 로직을 적용한다.

### 1. 정형 작업 (Operating Mode)
- **상황:** 컨베이어 벨트가 정상 작동하며 생산 활동을 하는 상태.
- **시스템 인식:** `is_conveyor_operating == True`
- **안전 목표:** 예방적 감속 및 비상 정지.
  - **일반 위험 (`high`):** 위험 구역 내 사람 감지 시, 속도를 50%로 감속 (`SLOW_DOWN_50_PERCENT`).
  - **심각 위험 (`critical`):** 작업자 넘어짐 감지 시, 즉시 컨베이어를 정지 (`STOP_POWER`).

### 2. 비정형 작업 (Stopped Mode)
- **상황:** 컨베이어가 의도적으로 멈춰진 상태에서 작업자가 수리/점검 등을 하는 상태.
- **시스템 인식:** `is_conveyor_operating == False`
- **안전 목표:** **전원 원천 차단 (LOTO - Lock-Out/Tag-Out)**.
  - 작업자가 위험 구역 내에 있을 경우, 다른 사람이 실수로 컨베이어를 재가동하는 것을 막기 위해 전원 공급 자체를 차단 (`PREVENT_POWER_ON`).

---

## 🧱 시스템 아키텍처 및 데이터 흐름

이 시스템은 **두뇌(서버)**와 **근육(아두이노)**으로 구성되며, **USB 시리얼 통신**이라는 신경망으로 연결된다.

1.  **Input Layer (눈):** `InputAdapter`가 카메라 영상과 센서 데이터를 받아온다.
2.  **Detection Layer (인식):** `Detector`가 영상에서 사람, 넘어짐 등을 탐지한다.
3.  **Logic Layer (판단):** `LogicFacade`가 탐지 결과와 센서 데이터를 종합하여, 현재 작업 모드에 맞는 `actions` (예: `STOP_POWER`) 목록을 생성한다.
4.  **Control Layer (손과 입):** `ControlFacade`가 `actions` 목록을 받아 실제 장치를 제어한다.
    - **`SpeedController`:** `STOP_POWER` 같은 명령을 아두이노가 이해하는 `s0\n` 같은 시리얼 명령어로 번역하여 **USB 포트(COM9)**로 전송한다.
    - **`PowerController`:** 전원의 논리적 상태(ON/OFF)를 관리한다. (라즈베리파이를 사용하지 않으므로 실제 하드웨어 제어는 없음)
    - **`AlertController`:** 경광등, 사이렌 등 경고 장치를 제어한다.
5.  **Arduino (근육):** 시리얼 포트로 들어온 `s0\n` 같은 명령어를 해석하여 모터 드라이버에 신호를 보내 모터를 실제로 정지시킨다.

---

## ⚠️ 주요 디버깅 이슈 및 최종 해결 과정

프로젝트 개발 중, **"로직은 정상 작동하는 것처럼 보이나, 실제 아두이노 모터가 움직이지 않고 프레임 드랍이 발생하는"** 심각한 문제가 반복적으로 발생했다. 이 문제의 원인을 찾기 위해 다음과 같은 체계적인 디버깅 과정을 거쳤다.

### 1차 진단: 설정 및 통신 오류 (오진)
- **가설:** `mock_mode` 활성화, 포트/보드레이트 불일치, 명령어 형식 불일치.
- **검증:** `test_arduino_direct.py` 스크립트를 통해 아두이노와 직접 통신하는 데 성공. 이로써 하드웨어, 아두이노 코드, 통신 프로토콜 자체에는 문제가 없음을 확인.
- **결론:** 문제는 Python 애플리케이션 내부에 있음.

### 2차 진단: 포트 자동 탐지 실패 (부분적 원인)
- **가설:** `SpeedController`의 포트 자동 탐지 기능이 사용자 PC 환경의 COM 포트 설명을 인식하지 못해 연결에 실패함.
- **조치:** 자동 탐지 로직을 제거하고, `control/speed_controller.py`에 `port="COM9"`를 하드코딩하여 직접 명시.
- **결과:** 여전히 문제 해결되지 않음.

### 3차 진단: `AlertController`의 `time.sleep()` (오진)
- **가설:** 알람 발생 시 `time.sleep()`이 메인 스레드를 막아 프레임 드랍과 아두이노 미작동을 유발함.
- **검증:** 코드 확인 결과, 이미 `threading.Timer`를 사용 중이었음. 가설 기각.

### 4차 진단: 비동기 이벤트 루프 충돌 (오진)
- **가설:** 백그라운드 스레드에서 UI 알림을 위해 `asyncio.get_running_loop()`을 호출하다 `no running event loop` 오류가 발생하며 스레드가 멈춤.
- **조치:** `ControlFacade`가 메인 스레드의 이벤트 루프를 명시적으로 전달받아 사용하도록 수정.
- **결과:** 여전히 문제 해결되지 않음.

### 5차 진단: 데이터베이스 동기 쓰기 (오진)
- **가설:** DB에 로그를 기록하는 동기 작업(`collection.add()`)이 메인 스레드를 막음.
- **조치:** `db_service.py`가 DB 쓰기 작업을 별도의 스레드에서 처리하도록 수정.
- **결과:** 여전히 문제 해결되지 않음.

**최종 원인 및 해결: 설정 파일 이원화 및 DB 의존성**

긴 디버깅 끝에, 문제의 근본 원인이 두 가지 복합적인 이슈에 있었음을 발견했다.

1.  **설정 파일 이원화:**
    - **문제:** `uvicorn`으로 서버를 실행할 때는 `config/config.py`를 사용하지만, 개발 및 테스트 과정에서 `test/config.py`를 수정하고 있었음. 실제 운영 환경에 적용되는 `config/config.py`에는 `MOCK_MODE_CONTROL = True`가 그대로 남아있어, 모든 제어 모듈이 모의 모드로 작동하고 있었다.
    - **해결:** **`config/config.py`를 유일한 중앙 설정 파일로 지정**하고, `MOCK_MODE_CONTROL = False`와 `ARDUINO_PORT = "COM9"` 등 모든 최종 설정을 이 파일에 명시했다. `server/app.py`가 이 파일을 직접 읽어 각 모듈에 설정을 주입하도록 전체 구조를 재편성했다.

2.  **DB 모듈 의존성:**
    - **문제:** Firebase 인증서가 없는 환경에서 서버를 시작하면 `db_service` 객체가 `None`으로 초기화된다. 하지만 `background_worker`는 `db_service`가 `None`인지 확인하지 않고 `db_service.log_event()`를 호출하여 `AttributeError: 'NoneType' object has no attribute 'log_event'` 오류를 발생시켰다.
    - **해결:** `background_worker.py`에서 로그를 기록하는 부분을 `if service_facade.db_service:` 블록으로 감싸, **DB 서비스가 존재할 때만 로그를 기록하도록** 안전장치를 추가했다.

---

## 🧠 현재 상태 및 다음 단계

- **현재:** 모든 디버깅이 완료되었으며, 시스템은 의도한 대로 작동할 준비가 되었다. 서버 시작 시 모터가 100%로 회전하고, 넘어짐 감지 시 즉시 정지하는 핵심 기능이 모두 구현되었다.
- **다음 단계:** 실제 현장과 유사한 환경에서 다양한 시나리오(여러 명 등장, 조명 변화 등)를 테스트하여 시스템의 안정성과 강건성을 검증해야 한다.